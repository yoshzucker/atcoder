(let* ((n (read))
       (m (read))
       pn cn fn)
  (loop repeat n
        do (push (read) pn)
           (push (loop repeat (car (push (read) cn)) collect (read)) fn)
        finally (setf pn (nreverse pn))
                (setf cn (nreverse cn))
                (setf fn (nreverse fn)))
  (loop named outer for i below n for pii = (elt pn i) and fi = (elt fn i)
        do (loop for j below n for pj = (elt pn j) and fj = (elt fn j)
                 when (and (>= pii pj)
                           (subsetp fi fj)
                           (or (> pii pj)
                               (set-difference fj fi)))
                   do (return-from outer (princ "Yes")))
        finally (princ "No")))
