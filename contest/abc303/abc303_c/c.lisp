(let* ((n (read))
       (m (read))
       (h (read))
       (k (read))
       (s (read-line))
       (xym (loop repeat m collect (cons (read) (read)))))
  (loop for c across s with x = 0 and y = 0
        with hash = (make-hash-table :test #'equal)
          initially (loop for xy in xym do (setf (gethash xy hash) t))
        do (cond ((char= c #\R) (incf x))
                 ((char= c #\L) (decf x))
                 ((char= c #\U) (incf y))
                 ((char= c #\D) (decf y)))
           (when (minusp (decf h))
             (return (princ "No")))
           (when (and (gethash (cons x y) hash) (< h k))
             (setf (gethash (cons x y) hash) nil)
             (setf h (max h k)))
        finally (princ "Yes")))
